<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body, html { width: 100%; height: 100%; overflow: hidden; background: #000; }
    canvas { display: block; }
  </style>
</head>
<body>
<canvas id="canvas"></canvas>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const colors = ['#0ff', '#f80'];
let cycles = [];
let resetTimeout = null;

const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
function playCollisionSound() {
  const osc = audioCtx.createOscillator();
  osc.type = 'square';
  osc.frequency.setValueAtTime(200, audioCtx.currentTime);
  osc.connect(audioCtx.destination);
  osc.start();
  osc.stop(audioCtx.currentTime + 0.1);
}

function newCycle(color, avoidX, avoidY) {
  let x, y;
  do {
    x = Math.floor(Math.random() * canvas.width);
    y = Math.floor(Math.random() * canvas.height);
  } while (avoidX !== undefined && Math.abs(x - avoidX) < 50 && Math.abs(y - avoidY) < 50);
  
  let dir = Math.floor(Math.random() * 4) * 90;
  let velocity = directionToVelocity(dir);
  return {
    x: x,
    y: y,
    dir: dir,
    dx: velocity.dx,
    dy: velocity.dy,
    speed: 2,
    color: color,
    trail: [{x: x, y: y}]
  };
}

function directionToVelocity(dir) {
  switch(dir) {
    case 0: return {dx: 1, dy: 0};
    case 90: return {dx: 0, dy: 1};
    case 180: return {dx: -1, dy: 0};
    case 270: return {dx: 0, dy: -1};
  }
}

function resetGame() {
  clearTimeout(resetTimeout);
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  let c1 = newCycle(colors[0]);
  let c2 = newCycle(colors[1], c1.x, c1.y);
  cycles = [c1, c2];
}

function checkCollision(cycle) {
  if (cycle.x < 0 || cycle.x > canvas.width || cycle.y < 0 || cycle.y > canvas.height) return true;
  for (let point of cycle.trail) {
    if (point.x === cycle.x && point.y === cycle.y) return true;
  }
  let other = cycles.find(c => c !== cycle);
  for (let point of other.trail) {
    if (point.x === cycle.x && point.y === cycle.y) return true;
  }
  return false;
}

function lookAhead(cycle) {
  let futureX = cycle.x + cycle.dx * cycle.speed;
  let futureY = cycle.y + cycle.dy * cycle.speed;

  if (futureX < 0 || futureX > canvas.width || futureY < 0 || futureY > canvas.height) return true;
  
  for (let point of cycle.trail) {
    if (point.x === futureX && point.y === futureY) return true;
  }
  
  let other = cycles.find(c => c !== cycle);
  for (let point of other.trail) {
    if (point.x === futureX && point.y === futureY) return true;
  }
  
  return false;
}

function avoidCollision(cycle) {
  if (lookAhead(cycle)) {
    cycle.dir += Math.random() > 0.5 ? 90 : -90;
    cycle.dir = (cycle.dir + 360) % 360;
    let vel = directionToVelocity(cycle.dir);
    cycle.dx = vel.dx;
    cycle.dy = vel.dy;
  }
}

function draw() {
  for (let c of cycles) {
    avoidCollision(c);
    c.x += c.dx * c.speed;
    c.y += c.dy * c.speed;
    c.trail.push({x: c.x, y: c.y});

    ctx.beginPath();
    ctx.moveTo(c.trail[0].x, c.trail[0].y);
    for (let i = 1; i < c.trail.length; i++) {
      ctx.lineTo(c.trail[i].x, c.trail[i].y);
    }
    ctx.strokeStyle = c.color;
    ctx.shadowColor = c.color;
    ctx.shadowBlur = 10;
    ctx.lineWidth = 6;
    ctx.stroke();
    ctx.shadowBlur = 0;

    if (checkCollision(c)) {
      playCollisionSound();
      resetTimeout = setTimeout(resetGame, 1000);
      return;
    }
  }
  requestAnimationFrame(draw);
}

resetGame();
draw();

window.addEventListener('resize', () => {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  resetGame();
});
</script>
</body>
</html>
