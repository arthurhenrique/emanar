<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="TRON Hardcore Canvas Animation - Projeto de TI, Tech, Desenvolvimento, Dev, Coding, Neon Art, Creative Coding">
  <meta name="keywords" content="TI, Tech, Dev, Desenvolvimento, Programação, Coding, Canvas, JavaScript, Creative Coding, TRON, Neon, Tela de Descanso">
  <meta name="author" content="arthur e seu bot favorito">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body, html { width: 100%; height: 100%; overflow: hidden; background: #000; }
    canvas { display: block; }
  </style>
</head>
<body>
<canvas id="canvas"></canvas>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const colors = ['#0ff', '#f0f', '#ff0', '#0f0', '#f00', '#00f', '#fff'];
const cycles = [];

for(let i=0; i<10; i++) {
  cycles.push(newCycle());
}

function newCycle() {
  let x = Math.floor(Math.random() * canvas.width);
  let y = Math.floor(Math.random() * canvas.height);
  let dir = Math.floor(Math.random() * 4) * 90;
  let velocity = directionToVelocity(dir);
  return {
    x: x,
    y: y,
    dir: dir,
    dx: velocity.dx,
    dy: velocity.dy,
    speed: 5,
    color: colors[Math.floor(Math.random() * colors.length)],
    segments: [{x: x, y: y}],
    alive: true
  };
}

function directionToVelocity(dir) {
  switch(dir) {
    case 0: return {dx: 1, dy: 0};
    case 90: return {dx: 0, dy: 1};
    case 180: return {dx: -1, dy: 0};
    case 270: return {dx: 0, dy: -1};
  }
}

function draw() {
  ctx.fillStyle = 'rgba(0,0,0,0.1)';
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  cycles.forEach((c, idx) => {
    if(!c.alive) return;

    c.x += c.dx * c.speed;
    c.y += c.dy * c.speed;

    c.segments.push({x: c.x, y: c.y});
    if (c.segments.length > 50) c.segments.shift();

    ctx.beginPath();
    ctx.moveTo(c.segments[0].x, c.segments[0].y);
    for(let i=1; i<c.segments.length; i++) {
      ctx.lineTo(c.segments[i].x, c.segments[i].y);
    }
    ctx.strokeStyle = c.color;
    ctx.shadowColor = c.color;
    ctx.shadowBlur = 10;
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.shadowBlur = 0;

    if (Math.random() < 0.05) {
      c.dir += Math.random() > 0.5 ? 90 : -90;
      c.dir = (c.dir + 360) % 360;
      const vel = directionToVelocity(c.dir);
      c.dx = vel.dx;
      c.dy = vel.dy;
    }

    if (c.x < 0 || c.x > canvas.width || c.y < 0 || c.y > canvas.height) {
      cycles[idx] = newCycle();
    }
  });

  requestAnimationFrame(draw);
}

draw();

window.addEventListener('resize', () => {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
});
</script>
</body>
</html>
