<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body, html { width: 100%; height: 100%; overflow: hidden; background: #000; }
    canvas { display: block; }
  </style>
</head>
<body>
<canvas id="canvas"></canvas>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const colors = ['#0ff', '#f80'];
let cycles = [];

const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
function playCollisionSound() {
  const osc = audioCtx.createOscillator();
  osc.type = 'square';
  osc.frequency.setValueAtTime(200, audioCtx.currentTime);
  osc.connect(audioCtx.destination);
  osc.start();
  osc.stop(audioCtx.currentTime + 0.1);
}

function newCycle(color) {
  let x = Math.floor(Math.random() * canvas.width);
  let y = Math.floor(Math.random() * canvas.height);
  let dir = Math.floor(Math.random() * 4) * 90;
  let velocity = directionToVelocity(dir);
  return {
    x: x,
    y: y,
    dir: dir,
    dx: velocity.dx,
    dy: velocity.dy,
    speed: 2,
    color: color,
    trail: [{x: x, y: y}]
  };
}

function directionToVelocity(dir) {
  switch(dir) {
    case 0: return {dx: 1, dy: 0};
    case 90: return {dx: 0, dy: 1};
    case 180: return {dx: -1, dy: 0};
    case 270: return {dx: 0, dy: -1};
  }
}

function resetGame() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  cycles = [newCycle(colors[0]), newCycle(colors[1])];
}

function checkCollision(cycle) {
  if (cycle.x < 0 || cycle.x > canvas.width || cycle.y < 0 || cycle.y > canvas.height) return true;
  for (let point of cycle.trail) {
    if (point.x === cycle.x && point.y === cycle.y) return true;
  }
  let other = cycles.find(c => c !== cycle);
  for (let point of other.trail) {
    if (point.x === cycle.x && point.y === cycle.y) return true;
  }
  return false;
}

function draw() {
  for (let c of cycles) {
    c.x += c.dx * c.speed;
    c.y += c.dy * c.speed;
    c.trail.push({x: c.x, y: c.y});

    ctx.beginPath();
    ctx.moveTo(c.trail[0].x, c.trail[0].y);
    for (let i = 1; i < c.trail.length; i++) {
      ctx.lineTo(c.trail[i].x, c.trail[i].y);
    }
    ctx.strokeStyle = c.color;
    ctx.shadowColor = c.color;
    ctx.shadowBlur = 10;
    ctx.lineWidth = 6;
    ctx.stroke();
    ctx.shadowBlur = 0;

    if (Math.random() < 0.05) {
      c.dir += Math.random() > 0.5 ? 90 : -90;
      c.dir = (c.dir + 360) % 360;
      let vel = directionToVelocity(c.dir);
      c.dx = vel.dx;
      c.dy = vel.dy;
    }

    if (checkCollision(c)) {
      playCollisionSound();
      resetGame();
      return;
    }
  }
  requestAnimationFrame(draw);
}

resetGame();
draw();

window.addEventListener('resize', () => {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  resetGame();
});
</script>
</body>
</html>
