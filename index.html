<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <style>
    * {margin:0;padding:0;box-sizing:border-box;}
    body, html {width:100%;height:100%;overflow:hidden;background:#000;}
    canvas {display:block;}
  </style>
</head>
<body>
<canvas id="canvas"></canvas>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const colors = ['#0ff', '#f80'];
let cycles = [];
const gridSize = 10;
const predictionDepth = 10;

function gridKey(x, y) {
  return `${Math.floor(x / gridSize)},${Math.floor(y / gridSize)}`;
}

function newCycle(color) {
  let x = Math.floor(Math.random() * canvas.width);
  let y = Math.floor(Math.random() * canvas.height);
  let dir = Math.floor(Math.random() * 4) * 90;
  let vel = directionToVelocity(dir);
  return { x, y, dir, dx: vel.dx, dy: vel.dy, speed: gridSize, color, trail: new Set([gridKey(x, y)]) };
}

function directionToVelocity(dir) {
  switch(dir) {
    case 0: return { dx: 1, dy: 0 };
    case 90: return { dx: 0, dy: 1 };
    case 180: return { dx: -1, dy: 0 };
    case 270: return { dx: 0, dy: -1 };
  }
}

function resetGame() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  cycles = [newCycle(colors[0]), newCycle(colors[1])];
}

function neighbors(x, y) {
  return [
    { x: x + gridSize, y },
    { x: x - gridSize, y },
    { x, y: y + gridSize },
    { x, y: y - gridSize }
  ].filter(n => n.x >= 0 && n.x <= canvas.width && n.y >= 0 && n.y <= canvas.height);
}

function predictTrail(cycle) {
  let trail = new Set([...cycle.trail]);
  let x = cycle.x;
  let y = cycle.y;
  let dir = cycle.dir;

  for (let i = 0; i < predictionDepth; i++) {
    const vel = directionToVelocity(dir);
    x += vel.dx * gridSize;
    y += vel.dy * gridSize;
    if (x < 0 || x > canvas.width || y < 0 || y > canvas.height) break;
    trail.add(gridKey(x, y));
  }
  return trail;
}

function chooseBestMove(cycle) {
  const other = cycles.find(c => c !== cycle);
  const ownTrail = new Set([...cycle.trail]);
  const otherTrail = new Set([...other.trail, ...predictTrail(other)]);

  const moves = [
    { dir: cycle.dir, vel: directionToVelocity(cycle.dir) },
    { dir: (cycle.dir + 90) % 360, vel: directionToVelocity((cycle.dir + 90) % 360) },
    { dir: (cycle.dir + 270) % 360, vel: directionToVelocity((cycle.dir + 270) % 360) }
  ];

  let bestMove = moves[0];
  let maxSafe = -1;

  for (let move of moves) {
    let nx = cycle.x + move.vel.dx * gridSize;
    let ny = cycle.y + move.vel.dy * gridSize;
    let safeSteps = 0;
    for (let i = 0; i < predictionDepth; i++) {
      const key = gridKey(nx, ny);
      if (ownTrail.has(key) || otherTrail.has(key) || nx < 0 || nx > canvas.width || ny < 0 || ny > canvas.height) break;
      safeSteps++;
      nx += move.vel.dx * gridSize;
      ny += move.vel.dy * gridSize;
    }
    if (safeSteps > maxSafe) {
      maxSafe = safeSteps;
      bestMove = move;
    }
  }

  return bestMove;
}

function draw() {
  for (let c of cycles) {
    const move = chooseBestMove(c);
    c.dir = move.dir;
    c.dx = move.vel.dx;
    c.dy = move.vel.dy;

    c.x += c.dx * c.speed;
    c.y += c.dy * c.speed;

    const key = gridKey(c.x, c.y);
    if (c.trail.has(key) || c.x < 0 || c.x > canvas.width || c.y < 0 || c.y > canvas.height) {
      resetGame();
      return;
    }

    c.trail.add(key);

    ctx.beginPath();
    ctx.arc(c.x, c.y, 5, 0, Math.PI * 2);
    ctx.fillStyle = c.color;
    ctx.shadowColor = c.color;
    ctx.shadowBlur = 10;
    ctx.fill();
    ctx.shadowBlur = 0;
  }

  requestAnimationFrame(draw);
}

resetGame();
draw();

window.addEventListener('resize', () => {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  resetGame();
});
</script>
</body>
</html>
